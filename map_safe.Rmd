---
title: "map_safe()"
author: "Kelly Pien, Lily Jin, Carol Liu"
date: "11/29/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(purrr)
library(dplyr)
library(readr)
```

```{r}
#always returns logical vector
#another function
#if map_safe returns all TRUE, else different behaviors: only return good results
map_safe_bubble <- function(.x, f, ...) {
  # .x: vector of paths to csvs
  # f: function that's being applied to the dataset
  # ... arguments
  if (length(.x) == 1) {
    #if there is one row in .x: get and return the row number
    a <- tryCatch(
      {
        #This is the try part
        map(.x, f, ...)
        TRUE
      },
      error = function(e) {
        message("Something went wrong")
        message("Here's the original error message")
        message(e)
        return(FALSE)
      },
      warning=function(w) {
        message("Here's the original warning message:")
        message(w)
            # Choose a return value in case of warning
        return(TRUE)
      }
      )
    return(a)
    }
  else {
    # else, split in halves and run map_safe on each half
    a <- .x[1] # Take the first element in the vector
    b <- .x[2:length(.x)] # the remaining elements went through the recursion again
    return(c(map_safe_bubble(a, f, ...), map_safe_bubble(b, f, ...)))
  }
}
```


```{r}
# another function: if map_safe returns all TRUE, else different behaviors: only return good results
#' Determine if you can apply a function to a vector without errors.
#' @param .x Vector of paths to csvs
#' @param f Function that's being applied to the dataset
#' @param ... Arguments
#' @return A logical vector
#' @example map_safe(iris$Sepal.Length, log)

map_safe_merge <- function(.x, f, ...) {
  #.x: vector of paths to csvs
  #f: function that's being applied to the dataset
  #... arguments
  if (length(.x) == 1) {
    #if there is one row in .x: get and return the row number
    
    a <- tryCatch(
      {
        #This is the try part
        purrr::map(.x, f, ...)
        
        TRUE
      },
      error = function(e) {
        message("Something went wrong")
        message("Here's the original error message")
        message(e)
        return(FALSE)
      },
      warning=function(w) {
        message("Here's the original warning message:")
        message(w)
        # Choose a return value in case of warning
        return(TRUE)
      }
    )
    return(a)
  }
  else {
    a <- .x[1:floor(length(.x)/2)] #first half of .x
    b <- .x[(floor(length(.x)/2)+1):length(.x)] #second half of .x
    return(c(map_safe_merge(a, f, ...), map_safe_merge(b, f, ...)))
  }
}

```

```{r}
check_match <- function(.data, ...){
  # Using `dplyr::filter()` to get the rows that matches the user's need and store them into row.
  row <- .data %>%
    filter(...)%>%
    # Count the number of rows that matches the user's need.
    nrow()
  # Return TRUE if the rows that matches the need is greater than 0, else return FALSE
  isTRUE(row > 0)
}
```

```{r}
sample_a <- sample_n(starwars, 34)
sample_b <- sample_n(mtcars, 1:20)
a <- list(starwars, sample_a, sample_b)
```

```{r}
map_safe_bubble(a, select,height)
map_safe_merge(a, select,height)
```



```{r}
library(readxl)
my_data <- read_excel("SDS390 test1.xlsx")
```

```{r}
map_safe_bubble(my_data, log)
map_safe_merge(my_data, log)
map_safe_bubble(starwars, length)
map_safe_merge(starwars, length)
```

```{r}
sample_a <- sample_n(starwars, 34)
sample_b <- sample_n(mtcars, 1:20)
a <- list(starwars, sample_a, sample_b)
map_safe_bubble(a, select, height)
map_safe_merge(a, select, height)
```

```{r}
setwd("~/Downloads")
mydir = "myfiles"
file_list = list.files(path=mydir, pattern="*.csv", full.names=TRUE)
file_list
myfiles = lapply(file_list,read_csv)
```

```{r}
map_safe_bubble(myfiles, select, pO2)
map_safe_merge(myfiles, select, pO2)
map_safe_bubble(myfiles, check_match, height==0)
map_safe_merge(myfiles, check_match, height==0)
```

